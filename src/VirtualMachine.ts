/**
    Copyright 2010 Steve Hanov
    Copyright 2019 Jan Starzak

    This file is part of qb.js

    qb.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    qb.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with qb.js.  If not, see <http://www.gnu.org/licenses/>.
*/

import { sprintf, getDebugConsole as dbg } from './DebugConsole'
import { Instruction } from './CodeGenerator'
import {
	DeriveTypeNameFromVariable,
	ScalarVariable,
	SomeScalarType,
	IsNumericType,
	ArrayVariable,
	Dimension,
	SomeType,
	StringType,
	JSONType
} from './Types'
import { IConsole } from './Console'
import { IAudioDevice } from './AudioDevice'
import { QBasicProgram } from './QBasic'
import { Locus } from './Tokenizer'
import * as EventEmitter from 'eventemitter3'
import * as fetchPonyfill from 'fetch-ponyfill'
import { query as jsonPathQuery } from 'jsonpath'

const { fetch, Headers } = fetchPonyfill()

export enum RuntimeErrorCodes {
	DIVISION_BY_ZERO = 101,
	STACK_OVERFLOW = 201,
	STACK_UNDERFLOW = 202,
	UKNOWN_SYSCALL = 301,
	IO_ERROR = 401,
	INVALID_ARGUMENT = 405,
}

export class RuntimeError extends Error {
	private _code: RuntimeErrorCodes
	get code(): RuntimeErrorCodes {
		return this._code
	}
	private _locus: Locus | undefined
	get locus(): Locus | undefined {
		return this._locus
	}
	constructor(code: RuntimeErrorCodes, message: string, locus?: Locus) {
		super(message)
		this._code = code
		this._locus = locus
	}
}

export class TraceBuffer {
	readonly MAX_LINES = 200
	lines: string[] = []
	constructor() {}

	public toString() {
		return this.lines.join('')
	}

	public printf(...args: any[]) {
		let str = sprintf(args)
		this.lines.push(str)
		if (this.lines.length > this.MAX_LINES) {
			this.lines.shift()
		}
		dbg().printf('%s', str)
	}
}

export class StackFrame {
	// Address to return to when the subroutine has ended.
	pc: any

	// map from name to the Scalar or Array variable.
	variables: object = {}

	constructor(pc: any) {
		this.pc = pc
		this.variables = {}
	}
}

const DEBUG = false

/**
 The VirtualMachine runs the bytecode given to it. It can run in one of two
 modes: Synchronously or Asynchronously.

 In synchronous mode, the program is run to completion before returning from
 the run() function. This can cause a browser window to freeze until execution
 completes.

 In asynchronous mode, a javascript interval is used. Every so often, we run
 some instructions and then stop. That way, the program appears to run while
 letting the user use the browser window.
 */
export class VirtualMachine extends EventEmitter<'error' | 'suspended' | 'resumed'> {
	// Stack
	stack: any[] = []

	// program counter.
	pc = 0

	// list of StackFrames. The last one is searched for variable references.
	// Failing that, the first one ( the main procedure ) is searched for any
	// shared variables matching the name.
	callstack: StackFrame[] = []

	// The console.
	cons: IConsole

	// The audio device
	audio: IAudioDevice | undefined

	// The bytecode (array of Instruction objects)
	instructions: Instruction[] = []

	// Array of user defined times.
	types: { [key: string]: SomeType } = {}

	// set of names of shared variables.
	shared: object = {}

	// Trace buffer for debugging.
	trace: TraceBuffer = new TraceBuffer()

	// Index of next data statement to be read.
	dataPtr: number = 0

	// Array of strings or numbers from the data statements.
	data: any[] = []

	// True if we are running asynchronously.
	asynchronous: boolean = false

	// True if the virtual machine is suspended for some reason (for example,
	// waiting for user input)
	suspended: boolean = false // eg. for INPUT statement.

	// The javascript interval used for running asynchronously.
	interval: number | undefined = undefined

	// Number of milliseconds between intervals
	private readonly INTERVAL_MS = 66 // ~15 fps

	// Number of instructions to run in an interval
	instructionsPerInterval = 32 * 1024

	// The last random number generated by a RND function. We have to remember
	// it because RND 0 returns the last one generated.
	lastRandomNumber = 0

	private defaultType: SomeScalarType

	frame: StackFrame

	cwd: string = ''

	/**
	 * @param console A Console object that will be used as the screen.
	 */
	constructor(console: IConsole, audio?: IAudioDevice) {
		super()
		this.cons = console
		this.audio = audio

		if (!DEBUG) {
			this.trace = { printf: function() {} } as TraceBuffer
		}
	}

	/**
     Resets the virtual machine, halting any running program.
    */
	public reset(program: QBasicProgram) {
		if (program) {
			this.instructions = program.instructions
			this.types = program.types
			this.defaultType = program.defaultType
			this.data = program.data
			this.shared = program.shared
		}

		this.stack.length = 0
		this.callstack.length = 0
		this.callstack.push(new StackFrame(this.instructions.length))
		this.frame = this.callstack[0]
		this.dataPtr = 0
		this.suspended = false
		if (this.interval) {
			window.clearInterval(this.interval)
			this.interval = undefined
		}

		this.pc = 0
		if (program) {
			this.cons.reset(program.testMode)
		} else {
			this.cons.reset()
		}
	}

	/**
     Run a program to completion in synchronous mode, or
    Starts running a program in asynchronous mode.

    In asynchronous mode, it returns immediately.
    */
	public run(program: QBasicProgram, synchronous: boolean) {
		this.reset(program)
		this.asynchronous = !synchronous

		if (synchronous) {
			try {
				while (this.pc < this.instructions.length) {
					this.runOneInstruction()
				}
			} catch (e) {
				this.emit('error', e)
			}
		} else {
			this.interval = setInterval(() => this.runSome(), this.INTERVAL_MS)
		}
	}

	/**
     Suspend the CPU, maintaining all state. This happens when the program
    is waiting for user input.
    */
	public suspend() {
		this.suspended = true
		this.emit('suspended')
		if (this.asynchronous) {
			clearInterval(this.interval)
		}
	}

	/**
     Resume the CPU, after previously being suspended.
    */
	public resume() {
		this.suspended = false
		this.emit('resumed')
		if (this.asynchronous) {
			this.runSome()
			this.interval = setInterval(() => this.runSome(), this.INTERVAL_MS)
		}
	}

	/**
     Runs some instructions during asynchronous mode.
    */
	public runSome() {
		try {
			for (
				let i = 0;
				i < this.instructionsPerInterval && this.pc < this.instructions.length && !this.suspended;
				i++
			) {
				this.runOneInstruction()
			}
		} catch (e) {
			this.suspend()
			if (e instanceof RuntimeError) {
				this.emit('error', e)
			} else {
				throw e
			}
		}

		if (this.pc === this.instructions.length) {
			clearInterval(this.interval)
		}
	}

	public runOneInstruction() {
		let instr = this.instructions[this.pc++]
		try {
			if (DEBUG) {
				this.trace.printf('Execute [%s] %s\n', this.pc - 1, instr)
			}
			instr.instr.execute(this, instr.arg)
		} catch (e) {
			if (e instanceof RuntimeError) {
				throw new RuntimeError(e.code, e.message, instr.locus)
			} else {
				throw e
			}
		}
	}

	/**
	 * Run all instructions on the current line of the program
	 */
	public runOneLine() {
		const currentLocus = this.instructions[this.pc].locus
		let i = 0
		do {
			this.runOneInstruction()
		} while (this.instructions[this.pc].locus.line === currentLocus.line && i++ < this.instructionsPerInterval) // don't get stuck in infinite loops
	}

	public setVariable(name: string, value: any) {
		if (this.shared[name]) {
			this.callstack[0].variables[name] = value
		} else {
			this.frame.variables[name] = value
		}
	}

	public getVariable(name: string) {
		let frame: StackFrame
		if (this.shared[name]) {
			frame = this.callstack[0]
		} else {
			frame = this.frame
		}

		if (frame.variables[name]) {
			return frame.variables[name]
		} else {
			// must create variable
			const typeName = DeriveTypeNameFromVariable(name)
			let type: SomeScalarType
			if (typeName === null) {
				type = this.defaultType
			} else {
				type = this.types[typeName] as SomeScalarType
			}

			let scalar = new ScalarVariable<any>(type, type.createInstance())
			frame.variables[name] = scalar
			return scalar
		}
	}

	public printStack() {
		if (DEBUG) {
			for (let i = 0; i < this.stack.length; i++) {
				let item = this.stack[i]
				let name = /*getObjectClass*/ item
				if (name === 'ScalarVariable') {
					name += ' ' + item.value
				}
				this.trace.printf('stack[%s]: %s\n', i, name)
			}
		}
	}

	public pushScalar(value, typeName) {
		this.stack.push(new ScalarVariable<any>(this.types[typeName] as SomeScalarType, value))
	}
}

function getArgValue<T>(variable: (ScalarVariable<T> | T)) {
	return variable instanceof ScalarVariable ? variable.value : variable
}

interface ISystemFunction {
	type: string
	args: string[]
	minArgs: number
	action: (vm: VirtualMachine) => void
}

type SystemFunctionsDefinition = {
	[key: string]: ISystemFunction
}

/**
    Defines the functions that can be called from a basic program. Functions
    must return a value. System subs, which do not return a value, are defined
    elsewhere. Some BASIC keywords, such as SCREEN, are both a function and a
    sub, and may do different things in the two contexts.

    Each entry is indexed by function name. The record contains:

    type: The name of the type of the return value of the function.

    args: An array of names of types of each argument.

    minArgs: the number of arguments required.

    action: A function taking the virtual machine as an argument. To implement
    the function, it should pop its arguments off the stack, and push its
    return value onto the stack. If minArgs <> args.length, then the top of the
    stack is an integer variable that indicates how many arguments were passed
    to the function.
 */
export const SystemFunctions: SystemFunctionsDefinition = {
	RND: {
		type: 'SINGLE',
		args: ['INTEGER'],
		minArgs: 0,
		action: function(vm) {
			let numArgs = vm.stack.pop()
			let n = 1
			if (numArgs === 1) {
				n = vm.stack.pop()
			}
			if (n === 0) {
				vm.stack.push(vm.lastRandomNumber)
			} else {
				vm.stack.push(Math.random())
			}
		}
	},

	CHR$: {
		type: 'STRING',
		args: ['INTEGER'],
		minArgs: 1,
		action: function(vm) {
			let num = vm.stack.pop()
			vm.stack.push(String.fromCharCode(num))
		}
	},

	INKEY$: {
		type: 'STRING',
		args: [],
		minArgs: 0,
		action: function(vm) {
			let code = vm.cons.getKeyFromBuffer()
			let result = ''

			if (code !== -1) {
				result = String.fromCodePoint(code)
				if (code === 0) {
					result += String.fromCharCode(vm.cons.getKeyFromBuffer())
				}
			}

			vm.stack.push(result)
		}
	},

	LEN: {
		type: 'INTEGER',
		args: ['ANY'],
		minArgs: 1,
		action: function(vm) {
			const variable = vm.stack.pop()
			if (variable instanceof ArrayVariable) {
				vm.stack.push(variable.values.length)
				return
			} else if (variable instanceof ScalarVariable && variable.type.name === 'STRING') {
				vm.stack.push(variable.value.length)
				return
			} else if (typeof variable === 'string') {
				vm.stack.push(variable.length)
				return
			}

			throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for LEN')
		}
	},

	MID$: {
		type: 'STRING',
		args: ['STRING', 'INTEGER', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			let numArgs = vm.stack.pop()
			let len
			if (numArgs === 3) {
				len = vm.stack.pop()
			}
			let start = vm.stack.pop()
			let str = vm.stack.pop()
			vm.stack.push(str.substr(start - 1, len))
		}
	},

	LEFT$: {
		type: 'STRING',
		args: ['STRING', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			let num = vm.stack.pop()
			let str = vm.stack.pop()
			vm.stack.push(str.substr(0, num))
		}
	},

	RIGHT$: {
		type: 'STRING',
		args: ['STRING', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			let num = vm.stack.pop()
			let str = vm.stack.pop()
			vm.stack.push(str.substr(str.length - num))
		}
	},

	INSTR: {
		type: 'INTEGER',
		args: ['ANY', 'STRING', 'STRING'],
		minArgs: 2,
		action: function(vm) {
			let numArgs = vm.stack.pop()
			let needle: string = vm.stack.pop()
			let haystack: string = vm.stack.pop()
			let start = 0
			if (numArgs > 2) {
				start = vm.stack.pop()
			}
			vm.stack.push(haystack.indexOf(needle, start))
		}
	},

	TIMER: {
		type: 'INTEGER',
		args: [],
		minArgs: 0,
		action: function(vm) {
			// return number of seconds since midnight. DEVIATION: We return a
			// floating point value rather than an integer, so that nibbles
			// will work properly when its timing loop returns a value less
			// than one second.
			let date = new Date()

			let result =
				date.getMilliseconds() / 1000 + date.getSeconds() + date.getMinutes() * 60 + date.getHours() * 60 * 60

			vm.stack.push(result)
		}
	},

	TIME$: {
		type: 'STRING',
		args: [],
		minArgs: 0,
		action: function(vm) {
			vm.stack.push((new Date()).toISOString().substr(11, 8))
		}
	},

	DATE$: {
		type: 'STRING',
		args: [],
		minArgs: 0,
		action: function(vm) {
			vm.stack.push((new Date()).toISOString().substr(0, 10))
		}
	},

	PEEK: {
		type: 'INTEGER',
		args: ['INTEGER'],
		minArgs: 1,
		action: function(vm) {
			// pop one argument off the stack and replace it with 0.
			vm.stack.pop()
			vm.stack.push(0)
		}
	},

	LCASE$: {
		type: 'STRING',
		args: ['STRING'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(vm.stack.pop().toLowerCase())
		}
	},

	UCASE$: {
		type: 'STRING',
		args: ['STRING'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(vm.stack.pop().toUpperCase())
		}
	},

	TRIM$: {
		type: 'STRING',
		args: ['STRING'],
		minArgs: 1,
		action: function (vm) {
			vm.stack.push(vm.stack.pop().trim())
		}
	},

	STR$: {
		type: 'STRING',
		args: ['SINGLE', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const numArgs = vm.stack.pop()
			let pad = 0
			if (numArgs > 1) {
				pad = vm.stack.pop()
			}

			const num = vm.stack.pop()
			const result = Number(num).toString(10)
			vm.stack.push('0000000000000000000000000000000000000000000000000000'.substr(0, pad - result.length) + result)
		}
	},

	HEX$: {
		type: 'STRING',
		args: ['SINGLE', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const numArgs = vm.stack.pop()
			let pad = 0
			if (numArgs > 1) {
				pad = vm.stack.pop()
			}

			const num = vm.stack.pop()
			const result = Number(num).toString(16)
			vm.stack.push('0000000000000000000000000000000000000000000000000000'.substr(0, pad - result.length) + result)
		}
	},

	SPACE$: {
		type: 'STRING',
		args: ['INTEGER'],
		minArgs: 1,
		action: function(vm) {
			let numSpaces = vm.stack.pop()
			let str = ''
			for (let i = 0; i < numSpaces; i++) {
				str += ' '
			}
			vm.stack.push(str)
		}
	},

	VAL: {
		type: 'SINGLE',
		args: ['STRING'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(parseFloat(vm.stack.pop()))
		}
	},

	INT: {
		type: 'INTEGER',
		args: ['SINGLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.floor(vm.stack.pop()))
		}
	},

	FLOOR: {
		type: 'INTEGER',
		args: ['SINGLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.floor(vm.stack.pop()))
		}
	},

	CEIL: {
		type: 'INTEGER',
		args: ['SINGLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.ceil(vm.stack.pop()))
		}
	},

	ROUND: {
		type: 'INTEGER',
		args: ['SINGLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.round(vm.stack.pop()))
		}
	},

	SQR: {
		type: 'DOUBLE',
		args: ['ANY'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.sqrt(Number(vm.stack.pop())))
		}
	},

	SGN: {
		type: 'INTEGER',
		args: ['ANY'],
		minArgs: 1,
		action: function(vm) {
			const val = Number(vm.stack.pop())
			vm.stack.push(val === 0 ? 0 : val < 0 ? -1 : 1)
		}
	},

	EXP: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.exp(vm.stack.pop()))
		}
	},

	LOG: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.log(vm.stack.pop()))
		}
	},

	POW: {
		type: 'DOUBLE',
		args: ['DOUBLE', 'DOUBLE'],
		minArgs: 2,
		action: function(vm) {
			const multiplier = vm.stack.pop()
			const value = vm.stack.pop()
			vm.stack.push(Math.pow(value, multiplier))
		}
	},

	PI: {
		type: 'DOUBLE',
		args: [],
		minArgs: 0,
		action: function(vm) {
			vm.stack.push(Math.PI)
		}
	},

	RAD: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(vm.stack.pop() / 360 * 2 * Math.PI)
		}
	},

	DEG: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(vm.stack.pop() / 2 / Math.PI * 360)
		}
	},

	SIN: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.sin(vm.stack.pop()))
		}
	},

	COS: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.cos(vm.stack.pop()))
		}
	},

	TAN: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.tan(vm.stack.pop()))
		}
	},

	ASIN: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.asin(vm.stack.pop()))
		}
	},

	ACOS: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.acos(vm.stack.pop()))
		}
	},

	ATAN: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.atan(vm.stack.pop()))
		}
	},

	SINH: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.sinh(vm.stack.pop()))
		}
	},

	COSH: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.cosh(vm.stack.pop()))
		}
	},

	TANH: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.tanh(vm.stack.pop()))
		}
	},

	CLASSIFY: {
		type: 'DOUBLE',
		args: ['DOUBLE'],
		minArgs: 1,
		action: function(vm) {
			const value = vm.stack.pop()
			vm.stack.push(Number.isNaN(value) ? 2 : Number.isFinite(value) ? 0 : 1)
		}
	},

	ABS: {
		type: 'DOUBLE',
		args: ['ANY'],
		minArgs: 1,
		action: function(vm) {
			vm.stack.push(Math.abs(Number(vm.stack.pop())))
		}
	},

	MIN: {
		type: 'DOUBLE',
		args: ['ANY', 'ANY'],
		minArgs: 1,
		action: function(vm) {
			const numArgs = vm.stack.pop()

			const variable = vm.stack.pop()
			if (numArgs === 1 && variable instanceof ArrayVariable && IsNumericType(variable.type)) {
				vm.stack.push(Math.min(...(variable.values.map(item => Number(item.value)))))
				return
			} else if (typeof variable === 'number') {
				const values = [ Number(variable) ]
				for (let i = 1; i < numArgs; i++) {
					const nextVariable = vm.stack.pop()
					if (typeof nextVariable !== 'number') throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for MAX')
					values.push(Number(nextVariable))
				}
				vm.stack.push(Math.min(...values))
				return
			}

			throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for MIN')
		}
	},

	MAX: {
		type: 'DOUBLE',
		args: ['ANY', 'ANY'],
		minArgs: 1,
		action: function(vm) {
			const numArgs = vm.stack.pop()

			const variable = vm.stack.pop()
			if (numArgs === 1 && variable instanceof ArrayVariable && IsNumericType(variable.type)) {
				vm.stack.push(Math.max(...(variable.values.map(item => Number(item.value)))))
				return
			} else if (typeof variable === 'number') {
				const values = [ Number(variable) ]
				for (let i = 1; i < numArgs; i++) {
					const nextVariable = vm.stack.pop()
					if (typeof nextVariable !== 'number') throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for MAX')
					values.push(Number(nextVariable))
				}
				vm.stack.push(Math.max(...values))
				return
			}

			throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for MAX')
		}
	},

	IMGLOAD: {
		type: 'INTEGER',
		args: ['STRING'],
		minArgs: 1,
		action: function(vm) {
			vm.suspend()
			const fileName = vm.stack.pop()
			vm.cons
				.loadImage(vm.cwd + fileName)
				.then(idx => {
					vm.stack.push(idx)
					vm.resume()
				})
				.catch(() => {
					vm.stack.push(-1)
					vm.resume()
				})
		}
	},

	RGB: {
		type: 'INTEGER',
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			const blue = vm.stack.pop()
			const green = vm.stack.pop()
			const red = vm.stack.pop()
			vm.stack.push(-1 * ((((red >> 3) & 31) << 10) + (((green >> 3) & 31) << 5) + (((blue >> 3) & 31))))
		}
	},

	BGMCHK: {
		type: 'INTEGER',
		args: [],
		minArgs: 0,
		action: function(vm) {
			vm.stack.push((vm.audio && vm.audio.isPlayingMusic()) ? -1 : 0)
		}
	},

	'JSONREAD%': {
		type: 'INTEGER',
		args: ['JSON', 'STRING', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			// this also converts JSON true and false to -1 and 0
			const numArgs = vm.stack.pop()
			let defValue = 0

			if (numArgs > 2) {
				defValue = vm.stack.pop()
			}
			const path = vm.stack.pop()
			const obj = vm.stack.pop()

			const resultArr = jsonPathQuery(obj, path)
			if (resultArr.length === 0) {
				vm.stack.push(defValue)
			} else {
				const result = resultArr[0]
				vm.stack.push(
					typeof result === 'boolean'
					? result === true
						? -1 : 0
					: Math.round(result)
				)
			}
		}
	},

	'JSONREAD#': {
		type: 'DOUBLE',
		args: ['JSON', 'STRING', 'DOUBLE'],
		minArgs: 2,
		action: function(vm) {
			const numArgs = vm.stack.pop()
			let defValue = 0

			if (numArgs > 2) {
				defValue = vm.stack.pop()
			}
			const path = vm.stack.pop()
			const obj = vm.stack.pop()

			const resultArr = jsonPathQuery(obj, path)
			if (resultArr.length === 0) {
				vm.stack.push(defValue)
			} else {
				const result = resultArr[0]
				vm.stack.push(Number(result))
			}
		}
	},

	'JSONREAD$': {
		type: 'STRING',
		args: ['JSON', 'STRING', 'STRING'],
		minArgs: 2,
		action: function(vm) {
			const numArgs = vm.stack.pop()
			let defValue = ''

			if (numArgs > 2) {
				defValue = vm.stack.pop()
			}
			const path = vm.stack.pop()
			const obj = vm.stack.pop()

			const resultArr = jsonPathQuery(obj, path)
			if (resultArr.length === 0) {
				vm.stack.push(defValue)
			} else {
				vm.stack.push(String(resultArr[0] ?? defValue))
			}
		}
	},

	JSONPARSE: {
		type: 'JSON',
		args: ['STRING'],
		minArgs: 1,
		action: function(vm) {
			let obj = {}
			try {
				obj = JSON.parse(vm.stack.pop())
			} catch (e) {

			}
			vm.stack.push(obj)
		}
	},

	'JSONSTR$': {
		type: 'STRING',
		args: ['JSON'],
		minArgs: 1,
		action: function(vm) {
			let obj = vm.stack.pop()

			if (typeof obj !== 'object') {
				throw new RuntimeError(RuntimeErrorCodes.INVALID_ARGUMENT, 'Invalid argument for JSONSTR$')
			}

			vm.stack.push(JSON.stringify(obj, undefined, 1))
		}
	},
}

interface ISystemSubroutine {
	args?: string[]
	minArgs?: number
	action: (vm: VirtualMachine) => void
}

type SystemSubroutinesDefinition = {
	[key: string]: ISystemSubroutine
}

/**
    Defines the system subroutines that can be called from a basic program.
    Functions must return a value. System functions, which return a value, are
    defined elsewhere.

    Each entry is indexed by the name of the subroutine. The record contains:

    args: An array of names of types of each argument.

    minArgs: (optional) the number of arguments required.

    action: A function taking the virtual machine as an argument. To implement
    the function, it should pop its arguments off the stack, and push its
    return value onto the stack. If minArgs is present, and not equal to
    args.length, then the top of the stack is an integer variable that
    indicates how many arguments were passed to the function.
 */
export const SystemSubroutines: SystemSubroutinesDefinition = {
	HCF: {
		args: [],
		minArgs: 0,
		action: function(vm) {
			debugger

			// remove passed in arguments
			let numArgs = vm.stack.pop()
			while (numArgs--) {
				vm.stack.pop()
			}
		}
	},

	BEEP: {
		action: function() {
			// NOT IMPLEMENTED
		}
	},

	CLS: {
		action: function(vm) {
			// clears the console screen.
			vm.cons.cls()
		}
	},

	RANDOMIZE: {
		action: function(vm) {
			// NOT IMPLEMENTED. Seeding the random number generator
			// is not possible using the built-in Javascript functions.
			vm.stack.pop()
		}
	},

	PLAY: {
		args: ['STRING', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let repeat: number | undefined = undefined
			const music = getArgValue(vm.stack.pop())

			if (argCount > 1) {
				repeat = getArgValue(vm.stack.pop())
			}

			if (vm.audio) {
				vm.suspend()
				vm.audio
					.playMusic(music, repeat || 1)
					.then(() => {
						vm.resume()
					})
					.catch(e => console.error(e))
			}
		}
	},

	BGMPLAY: {
		args: ['STRING', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			// BGMPLAY is the same as PLAY, it just doesn't suspend the VM
			const argCount = vm.stack.pop()
			let repeat: number | undefined = undefined
			const music = getArgValue(vm.stack.pop())

			if (argCount > 1) {
				repeat = getArgValue(vm.stack.pop())
			}

			if (vm.audio) {
				vm.audio.playMusic(music, repeat).catch(e => console.error(e))
			}
		}
	},

	BGMSTOP: {
		action: function(vm) {
			if (vm.audio) {
				vm.audio.stopMusic()
			}
		}
	},

	SOUND: {
		args: ['INTEGER', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let volume = 1
			if (argCount > 2) {
				volume = getArgValue(vm.stack.pop()) / 255
			}
			const length = Math.max(1, Math.min(5000, Math.round(getArgValue(vm.stack.pop()))))
			const frequency = Math.round((Math.round(getArgValue(vm.stack.pop())) / 255 * (4000 - 12)) + 12)

			if (vm.audio) {
				vm.audio.makeSound(frequency, length, volume).catch(e => console.error(e))
			}
		}
	},

	SLEEP: {
		args: ['SINGLE'],
		minArgs: 0,
		action: function(vm) {
			const argCount = vm.stack.pop()
			vm.suspend()
			if (argCount === 1) {
				// if an argument is provided, wait X seconds
				const sleep = getArgValue(vm.stack.pop())
				let cancelSleep: () => void

				const timeout = setTimeout(() => {
					vm.off('suspended', cancelSleep)
					vm.resume()
				}, sleep * 1000)
				cancelSleep = () => {
					clearTimeout(timeout)
				}

				vm.once('suspended', cancelSleep)
			} else {
				// if no argument is provided, use a global trapped key to resume
				let cancelSleep: () => void

				vm.cons.onKey(-1, () => {
					vm.off('suspended', cancelSleep)
					vm.cons.onKey(-1, undefined)
					vm.resume()
				})
				cancelSleep = () => {
					vm.cons.onKey(-1, undefined)
				}

				vm.once('suspended', cancelSleep)
			}
		}
	},

	SYSTEM: {
		action: function() {
			// NOT IMPLEMENTED
			// vm.stack.pop();
		}
	},

	print_using: {
		action: function(vm) {
			// pop # args
			let argCount = vm.stack.pop()

			// pop terminator
			let terminator = vm.stack.pop()

			let args: any[] = []
			for (let i = 0; i < argCount - 1; i++) {
				args.unshift(vm.stack.pop())
			}

			let formatString = args.shift().value

			let curArg = 0
			let output = ''

			// for each character in the string,
			for (let pos = 0; pos < formatString.length; pos++) {
				let ch = formatString.charAt(pos)

				// if the character is '#',
				if (ch === '#') {
					// if out of arguments, then type mismatch error.
					if (curArg === args.length || !IsNumericType(args[curArg].type)) {
						// TODO: errors.
						dbg().printf('Type mismatch error.\n')
						break
					}

					// store character position
					let backupPos = pos
					let digitCount = 0
					// for each character of the string,
					for (; pos < formatString.length; pos++) {
						ch = formatString.charAt(pos)
						// if the character is '#',
						if (ch === '#') {
							// increase digit count
							digitCount++

							// if the character is ','
						} else if (ch === ',') {
							// do nothing
						} else {
							// break out of loop
							break
						}
					}

					// convert current arg to a string. Truncate or pad to
					// appropriate number of digits.
					let argAsString = '' + args[curArg].value
					if (argAsString.length > digitCount) {
						argAsString = argAsString.substr(argAsString.length - digitCount)
					} else {
						while (argAsString.length < digitCount) {
							argAsString = ' ' + argAsString
						}
					}

					let curDigit = 0

					// go back to old character position.
					// for each character of the string,
					for (pos = backupPos; pos < formatString.length; pos++) {
						ch = formatString.charAt(pos)
						// if the character is a '#'
						if (ch === '#') {
							// output the next digit.
							output += argAsString[curDigit++]
							// if the character is a ',',
						} else if (ch === ',') {
							// output a comma.
							output += ch
						} else {
							// break out.
							break
						}
					}

					// increment current argument.
					curArg += 1
					pos -= 1
				} else {
					// character was not #. output it verbatim.
					output += ch
				}
			}

			vm.cons.print(output)
			if (terminator === ',') {
				let x = vm.cons.x
				let spaces = ''
				while (++x % 14) {
					spaces += ' '
				}
				vm.cons.print(spaces)
			} else if (terminator !== ';') {
				vm.cons.print('\n')
			}
		}
	},

	LOCATE: {
		args: ['INTEGER', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let col = 1
			if (argCount > 1) {
				col = getArgValue(vm.stack.pop())
			}
			let row = getArgValue(vm.stack.pop())
			vm.cons.locate(row, col)
		}
	},

	COLOR: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()

			let bg: number | null = null
			let bo: number | null = null
			if (argCount > 2) {
				bo = Math.round(getArgValue(vm.stack.pop())) || 0
			}
			if (argCount > 1) {
				bg = Math.round(getArgValue(vm.stack.pop())) || 0
			}
			let fg = Math.round(getArgValue(vm.stack.pop())) || 0
			vm.cons.color(fg, bg, bo)
		}
	},

	READ: {
		// Actually, arguments must be STRING or NUMBER, but there is no way to
		// indicate that to the type checker at the moment.
		args: ['ANY', 'ANY'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let args: any[] = []
			let i

			for (i = 0; i < argCount; i++) {
				args.unshift(vm.stack.pop())
			}

			// TODO: out of data error.
			for (i = 0; i < argCount; i++) {
				vm.trace.printf('READ %s\n', vm.data[vm.dataPtr])
				args[i].value = vm.data[vm.dataPtr++]
				if (args[i].value === null) {
					// user specified ,, in a data statement
					args[i].value = args[i].type.createInstance()
				}
			}
		}
	},

	SCREEN: {
		action: function(vm) {
			const mode = getArgValue(vm.stack.pop())
			vm.cons.screen(mode)
		}
	},

	INPUT: {
		action: function(vm) {
			// TODO: Support multiple arguments. Convert strings input by the
			// user to numbers.
			let argCount = vm.stack.pop()
			let args: any[] = []

			vm.trace.printf('Argcount=%s\n', argCount)

			for (let i = 0; i < argCount; i++) {
				args.unshift(vm.stack.pop())
			}

			vm.suspend()

			vm.cons
				.input()
				.then(result => {
					args[0].value = result
					vm.resume()
				})
				.catch(e => console.error(e))
		}
	},

	SWAP: {
		action: function(vm) {
			let lhs = vm.stack.pop()
			let rhs = vm.stack.pop()
			let temp = lhs.value
			lhs.value = rhs.value
			rhs.value = temp
			// TODO: Type checking.
		}
	},

	INC: {
		args: ['INTEGER', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let step = 1

			if (argCount > 1) {
				step = getArgValue(vm.stack.pop())
			}

			const variable = vm.stack.pop()
			variable.value = variable.value + step
		}
	},

	DEC: {
		args: ['INTEGER', 'INTEGER'],
		minArgs: 1,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let step = 1

			if (argCount > 1) {
				step = getArgValue(vm.stack.pop())
			}

			const variable = vm.stack.pop()
			variable.value = variable.value - step
		}
	},

	WIDTH: {
		action: function(vm) {
			// TODO: NOT IMPLEMENTED
			vm.stack.pop()
			vm.stack.pop()
		}
	},

	WAIT: {
		args: ['INTEGER'],
		minArgs: 0,
		action: function(vm) {
			vm.suspend()

			const argCount = vm.stack.pop()
			let frames = 1
			if (argCount === 1) {
				// if an argument is provided, wait X frames
				frames = getArgValue(vm.stack.pop())
			}

			let cancelWait: () => void
			if (window) {
				let waitedFrames = 0
				let frameRequest: number
				const waitFrame = () => {
					waitedFrames++
					if (waitedFrames >= frames) {
						vm.off('suspended', cancelWait)
						vm.resume()
					} else {
						frameRequest = window.requestAnimationFrame(waitFrame)
					}
				}
				frameRequest = window.requestAnimationFrame(waitFrame)
				cancelWait = () => window.cancelAnimationFrame(frameRequest)
			} else {
				const timeout = setTimeout(() => {
					vm.off('suspended', cancelWait)
					vm.resume()
				}, frames)
				cancelWait = () => clearTimeout(timeout)
			}

			vm.once('suspended', cancelWait)
		}
	},

	IMGPUT: {
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			let argCount = vm.stack.pop()
			let dw = undefined
			let dh = undefined
			let sx = undefined
			let sy = undefined
			let sw = undefined
			let sh = undefined
			if (argCount >= 9) {
				sh = getArgValue(vm.stack.pop())
				sw = getArgValue(vm.stack.pop())
				sy = getArgValue(vm.stack.pop())
				sx = getArgValue(vm.stack.pop())
			}
			if (argCount >= 5) {
				dh = getArgValue(vm.stack.pop())
				dw = getArgValue(vm.stack.pop())
			}
			const dy = getArgValue(vm.stack.pop())
			const dx = getArgValue(vm.stack.pop())
			const imageHandle = getArgValue(vm.stack.pop())
			vm.cons.putImage(vm.cons.getImage(imageHandle), dx, dy, dw, dh, sx, sy, sw, sh)
		}
	},

	IMGSIZE: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			const height = vm.stack.pop()
			const width = vm.stack.pop()
			const imageHandle = getArgValue(vm.stack.pop())
			const image = vm.cons.getImage(imageHandle)

			width.value = Math.round(image.naturalWidth)
			height.value = Math.round(image.naturalHeight)
		}
	},

	IMGCLEAR: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			const imageHandle = getArgValue(vm.stack.pop())

			vm.cons.clearImage(imageHandle)
		}
	},

	SPSET: {
		args: ['INTEGER', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			vm.suspend()
			let argCount = vm.stack.pop()
			let frames = 1
			if (argCount > 2) {
				frames = getArgValue(vm.stack.pop())
			}
			const imageHandle = getArgValue(vm.stack.pop())
			const spriteNum = getArgValue(vm.stack.pop())

			vm.cons
				.createSprite(spriteNum - 1, vm.cons.getImage(imageHandle), frames)
				.then(() => {
					vm.resume()
				})
				.catch(console.error)
		}
	},

	SPOFS: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		action: function(vm) {
			const y = getArgValue(vm.stack.pop())
			const x = getArgValue(vm.stack.pop())
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.offsetSprite(spriteNum - 1, x, y)
		}
	},

	SPSCALE: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		action: function(vm) {
			const scaleY = getArgValue(vm.stack.pop())
			const scaleX = getArgValue(vm.stack.pop())
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.scaleSprite(spriteNum - 1, scaleX, scaleY)
		}
	},

	SPROT: {
		args: ['INTEGER', 'INTEGER'],
		action: function(vm) {
			const angle = getArgValue(vm.stack.pop())
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.rotateSprite(spriteNum - 1, angle)
		}
	},

	SPHOME: {
		args: ['INTEGER', 'INTEGER', 'INTEGER'],
		action: function(vm) {
			const homeY = getArgValue(vm.stack.pop())
			const homeX = getArgValue(vm.stack.pop())
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.homeSprite(spriteNum - 1, homeX, homeY)
		}
	},

	SPHIDE: {
		// SPRITE%
		args: ['INTEGER'],
		action: function(vm) {
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.displaySprite(spriteNum - 1, false)
		}
	},

	SPSHOW: {
		// SPRITE%
		args: ['INTEGER'],
		action: function(vm) {
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.displaySprite(spriteNum - 1, true)
		}
	},

	SPANIM: {
		// SPRITE%, START_FRAME%, END_FRAME% [[, SPEED], LOOP]
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let loop = true
			let speed = 1
			if (argCount > 4) {
				loop = getArgValue(vm.stack.pop()) === 0 ? false : true
			}
			if (argCount > 3) {
				speed = Math.round(getArgValue(vm.stack.pop()))
			}
			const stopFrame = Math.round(getArgValue(vm.stack.pop()))
			const startFrame = Math.round(getArgValue(vm.stack.pop()))
			const spriteNum = Math.round(getArgValue(vm.stack.pop()))
			vm.cons.animateSprite(spriteNum - 1, startFrame - 1, stopFrame - 1, speed, loop)
		}
	},

	SPCLR: {
		// SPRITE%
		args: ['INTEGER'],
		action: function(vm) {
			const spriteNum = getArgValue(vm.stack.pop())
			vm.cons.clearSprite(spriteNum - 1)
		}
	},

	GLINE: {
		// X1%, Y1% [[, X2%, Y2%], COLOR%]
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 2,
		action: function(vm) {
			const argCount = vm.stack.pop()
			let x1: number
			let y1: number
			let x2: number | undefined = undefined
			let y2: number | undefined = undefined
			let color: number | undefined = undefined
			if (argCount > 2) {
				color = Math.round(getArgValue(vm.stack.pop()))
			}
			if (argCount > 3) {
				y2 = Math.round(getArgValue(vm.stack.pop()))
				x2 = Math.round(getArgValue(vm.stack.pop()))
			}
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			if (x2 !== undefined && y2 !== undefined) {
				vm.cons.line(x1, y1, x2, y2, color)
			} else {
				vm.cons.lineTo(x1, y1, color)
			}
		}
	},

	GBOX: {
		// X1%, Y1%, X2%, Y2% [, COLOR%]
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 4,
		action: function (vm) {
			const argCount = vm.stack.pop()
			let x1: number
			let y1: number
			let x2: number
			let y2: number
			let color: number | undefined

			if (argCount > 4) {
				color = Math.round(getArgValue(vm.stack.pop()))
			}
			y2 = Math.round(getArgValue(vm.stack.pop()))
			x2 = Math.round(getArgValue(vm.stack.pop()))
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			vm.cons.box(x1, y1, x2, y2, color)
		}
	},

	GFILL: {
		// X1%, Y1%, X2%, Y2% [, COLOR%]
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 4,
		action: function (vm) {
			const argCount = vm.stack.pop()
			let x1: number
			let y1: number
			let x2: number
			let y2: number
			let color: number | undefined

			if (argCount > 4) {
				color = Math.round(getArgValue(vm.stack.pop()))
			}
			y2 = Math.round(getArgValue(vm.stack.pop()))
			x2 = Math.round(getArgValue(vm.stack.pop()))
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			vm.cons.fill(x1, y1, x2, y2, color)
		}
	},

	GTRI: {
		// X1%, Y1%, X2%, Y2%, X3%, Y3% [, COLOR%]
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		minArgs: 6,
		action: function (vm) {
			const argCount = vm.stack.pop()
			let x1: number
			let y1: number
			let x2: number
			let y2: number
			let x3: number
			let y3: number
			let color: number | undefined

			if (argCount > 6) {
				color = Math.round(getArgValue(vm.stack.pop()))
			}
			y3 = Math.round(getArgValue(vm.stack.pop()))
			x3 = Math.round(getArgValue(vm.stack.pop()))
			y2 = Math.round(getArgValue(vm.stack.pop()))
			x2 = Math.round(getArgValue(vm.stack.pop()))
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			vm.cons.triangleFill(x1, y1, x2, y2, x3, y3, color)
		}
	},

	GCIRCLE: {
		// X%, Y% [[[[,FILL% ], ASPECT#], START_ANGLE#, END_ANGLE#], COLOR%]
		args: ['INTEGER', 'INTEGER', 'ANY', 'ANY', 'ANY', 'ANY', 'ANY', 'ANY'],
		minArgs: 3,
		action: function (vm) {
			const argCount = vm.stack.pop()
			let x1: number
			let y1: number
			let radius: number
			let startAngle: number | undefined
			let endAngle: number | undefined
			let color: number | undefined
			let aspect: number | undefined
			let fill = false

			if (argCount > 3) {
				color = Math.round(getArgValue(vm.stack.pop()))
			}
			if (argCount > 7) {
				fill = getArgValue(vm.stack.pop()) === 0 ? false : true
			}
			if (argCount > 6) {
				aspect = Number(getArgValue(vm.stack.pop()))
			}
			if (argCount > 4) {
				startAngle = Number(getArgValue(vm.stack.pop()))
				endAngle = Number(getArgValue(vm.stack.pop()))
			}
			radius = Number(getArgValue(vm.stack.pop()))
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			vm.cons.circle(x1, y1, radius, color, startAngle, endAngle, aspect, fill, false)
		}
	},

	GPSET: {
		// X%, Y%, RED, GREEN, BLUE
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		action: function (vm) {
			let x1: number
			let y1: number
			let red: number
			let green: number
			let blue: number

			blue = Math.round(getArgValue(vm.stack.pop())) & 255
			green = Math.round(getArgValue(vm.stack.pop())) & 255
			red = Math.round(getArgValue(vm.stack.pop())) & 255
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			vm.cons.putPixel(x1, y1, [red, green, blue])
		}
	},

	GPGET: {
		// X%, Y%, OUT RED%, OUT GREEN, OUT BLUE
		args: ['INTEGER', 'INTEGER', 'INTEGER', 'INTEGER', 'INTEGER'],
		action: function (vm) {
			let x1: number
			let y1: number

			const blueVar = vm.stack.pop() as ScalarVariable<number>
			const greenVar = vm.stack.pop() as ScalarVariable<number>
			const redVar = vm.stack.pop() as ScalarVariable<number>
			y1 = Math.round(getArgValue(vm.stack.pop()))
			x1 = Math.round(getArgValue(vm.stack.pop()))

			const [red, green, blue] = vm.cons.getPixel(x1, y1)

			redVar.value = red
			greenVar.value = green
			blueVar.value = blue
		}
	},

	JSONREAD: {
		// JSON_OBJ, JSON_PATH$, OUT JSON_OBJ()
		args: ['JSON', 'STRING', 'ARRAY OF JSON'],
		minArgs: 3,
		action: function(vm) {
			// numArgs
			vm.stack.pop()

			const target = vm.stack.pop() as ArrayVariable<JSONType>
			const path = getArgValue(vm.stack.pop())
			const obj = getArgValue(vm.stack.pop())

			const resultArr = jsonPathQuery(obj, path)
			target.resize([ new Dimension(1, resultArr.length) ])
			for (let i = 0; i < resultArr.length; i++) {
				target.assign([ i + 1 ], new ScalarVariable<object>(vm.types['JSON'] as JSONType, resultArr[i]))
			}
		}
	},

	JSONWRITE: {
		// JSON_OBJ, JSON_PATH$, VALUE, CONVERT_TO_BOOL
		args: ['JSON', 'STRING', 'ANY', 'INTEGER'],
		minArgs: 3,
		action: function(vm) {
			// optional fourth argument specifies if written INTEGER value should be converted to JSON boolean (<>0: TRUE, =0: FALSE)
			throw new RuntimeError(RuntimeErrorCodes.UKNOWN_SYSCALL, 'Not implemented')
		}
	},

	FETCH: {
		// URL$, OUT RESPONSE_CODE%, OUT DATA$ [, METHOD$ [, HEADERS$() [, BODY$]]]
		args: ['STRING', 'INTEGER', 'STRING', 'STRING', 'ARRAY OF STRING', 'STRING'],
		minArgs: 3,
		action: function (vm) {
			const argCount = vm.stack.pop()

			const headers = new Headers()
			let method = 'GET'
			let body: string | undefined = undefined

			if (argCount > 5) {
				body = getArgValue(vm.stack.pop())
			}
			if (argCount > 4) {
				const headersArray = vm.stack.pop() as ArrayVariable<StringType>
				const pairs = headersArray.values.length / 2
				let i = 0
				while (i < pairs) {
					headers.set(headersArray.values[i++].value, headersArray.values[i++].value)
				}
			}
			if (argCount > 3) {
				method = getArgValue(vm.stack.pop())
			}
			const outData = vm.stack.pop()
			const outResCode = vm.stack.pop()
			const url = getArgValue(vm.stack.pop())

			vm.suspend()
			fetch(url, {
				method,
				headers,
				body
			})
			.then((response) => Promise.all([response.status, response.text()]))
			.then((value) => {
				outResCode.value = value[0]
				outData.value = value[1]
				vm.resume()
			})
			.catch((reason) => {
				vm.trace.printf('Error while fetching data: %s\n', reason)
				outResCode.value = -1
				vm.resume()
			})
		}
	}
}

export interface IInstruction {
	name: string
	addrLabel?: boolean
	dataLabel?: boolean
	numArgs?: 0 | 1
	execute: (vm: VirtualMachine, arg: number | string | undefined) => void
}

interface IDataLabelInstruction extends IInstruction {
	dataLabel?: true
	numArgs?: 1
	execute: (vm: VirtualMachine, arg: number) => void
}

interface IAddrLabelInstruction extends IInstruction {
	addrLabel?: true
	numArgs?: 1
	execute: (vm: VirtualMachine, arg: number) => void
}

interface INoArgInstruction extends IInstruction {
	addrLabel?: false
	dataLabel?: false
	numArgs: 0
	execute: (vm: VirtualMachine, arg?: undefined) => void
}

type InstructionDefinition = {
	[key: string]: IDataLabelInstruction | IAddrLabelInstruction | INoArgInstruction
}

/**
 Defines the instruction set of the virtual machine. Each entry is indexed by
 the name of the instruction, and consists of a record of the following values:

 name: The name of the instruction for display purposes.

 addrLabel: If present, and set to "true", the argument of the instruction is
 interpretted as an address during the linking stage.

 dataLabel: If present, and set to "true", the argument of the instruction is
 the index of a DATA statement.

 numArgs: If present and set to 0, the instruction takes no arguments.
 Otherwise, it is assumed to take 1 argument.

 execute: A function taking as its first argument the virtual machine, and as
 its second argument the parameter of the instruction. It should manipulate the
 virtual machine's stack or program counter to implement the instruction.
 */
export const Instructions: InstructionDefinition = {
	FORLOOP: {
		name: 'forloop',
		addrLabel: true,
		execute: function(vm, arg) {
			// For loops are tedious to implement in bytecode, because
			// depending on whether STEP is positive or negative we either
			// compare the counter with < or >. To simplify things, we create
			// the forloop instruction to perform this comparison.

			// argument is the address of the end of the for loop.

			// stack is:
			// end value
			// step expression
			// loop variable REFERENCE

			// if the for loop is ended, then all three of its arguments are
			// popped off the stack, and we jump to the end address. Otherwise,
			// only the loop variable is popped and no branch is performed.

			let counter = vm.stack[vm.stack.length - 1]
			let step = vm.stack[vm.stack.length - 2]
			let end = vm.stack[vm.stack.length - 3]

			if ((step < 0 && counter < end) || (step > 0 && counter > end)) {
				vm.stack.length -= 3
				vm.pc = arg
			} else {
				vm.stack.pop()
			}
		}
	},

	COPYTOP: {
		name: 'copytop',
		numArgs: 0,
		execute: function(vm) {
			// Duplicates the top of the stack
			vm.stack.push(vm.stack[vm.stack.length - 1])
		}
	},

	RESTORE: {
		name: 'restore',
		dataLabel: true,
		execute: function(vm, arg) {
			// Restore the data pointer to the given value.
			if (vm.debug) {
				vm.trace.printf('RESTORE to %s\n', arg)
			}
			vm.dataPtr = arg
		}
	},

	POPVAL: {
		name: 'popval',
		execute: function(vm, arg) {
			// Argument is the name of the variable. Sets that variable's value
			// to the top of the stack.
			vm.getVariable(arg).value = vm.stack.pop()
		}
	},

	POP: {
		name: 'pop',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.pop()
		}
	},

	PUSHREF: {
		name: 'pushref',
		execute: function(vm, arg) {
			// The argument is the name of a variable. Push a reference to that
			// variable onto the top of the stack.
			vm.stack.push(vm.getVariable(arg))
		}
	},

	PUSHVALUE: {
		name: 'pushvalue',
		execute: function(vm, arg) {
			// The argument is the name of a variable. Push the value of that
			// variable to the top of the stack.
			vm.stack.push(vm.getVariable(arg).value)
		}
	},

	PUSHTYPE: {
		name: 'pushtype',
		execute: function(vm, arg) {
			// The argument is the name of a built-in or user defined type.
			// Push the type object onto the stack, for later use in an alloc
			// system call.
			vm.stack.push(vm.types[arg])
		}
	},

	POPVAR: {
		name: 'popvar',
		execute: function(vm, arg) {
			// Sets the given variable to refer to the top of the stack, and
			// pops the top of the stack. The stack top must be a reference.
			vm.setVariable(arg, vm.stack.pop())
		}
	},

	NEW: {
		name: 'new',
		execute: function(vm, arg) {
			// The argument is a typename. Replace the top of the stack with a
			// reference to that value, with the given type.
			let type = vm.types[arg]
			vm.stack.push(new ScalarVariable(type, type.copy(vm.stack.pop())))
		}
	},

	END: {
		name: 'end',
		numArgs: 0,
		execute: function(vm) {
			// End the program. The CPU ends the program when the program
			// counter reaches the end of the instructions, so make that happen
			// now.
			vm.pc = vm.instructions.length
		}
	},

	UNARY_OP: {
		name: 'unary_op',
		execute: function(vm, arg) {
			let rhs = vm.stack.pop()
			let value
			if (arg === 'NOT') {
				value = ~rhs
			} else {
				vm.trace.printf('No such unary operator: %s\n', arg)
			}

			vm.stack.push(value)
		}
	},

	'=': {
		name: '=',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.push(vm.stack.pop() === vm.stack.pop() ? -1 : 0)
		}
	},

	'<': {
		name: '<',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs < rhs ? -1 : 0)
		}
	},

	'<=': {
		name: '<=',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs <= rhs ? -1 : 0)
		}
	},

	'>': {
		name: '>',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs > rhs ? -1 : 0)
		}
	},

	'>=': {
		name: '>=',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs >= rhs ? -1 : 0)
		}
	},

	'<>': {
		name: '<>',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.push(vm.stack.pop() !== vm.stack.pop() ? -1 : 0)
		}
	},

	AND: {
		name: 'and',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.push(vm.stack.pop() & vm.stack.pop())
		}
	},

	OR: {
		name: 'or',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.push(vm.stack.pop() | vm.stack.pop())
		}
	},

	'^': {
		name: '^',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(Math.pow(lhs, rhs))
		}
	},

	'+': {
		name: '+',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs + rhs)
		}
	},

	'-': {
		name: '-',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs - rhs)
		}
	},

	'*': {
		name: '*',
		numArgs: 0,
		execute: function(vm) {
			vm.stack.push(vm.stack.pop() * vm.stack.pop())
		}
	},

	'>>': {
		name: '>>',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs >> rhs)
		}
	},

	'<<': {
		name: '<<',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			let lhs = vm.stack.pop()
			vm.stack.push(lhs << rhs)
		}
	},

	'/': {
		name: '/',
		numArgs: 0,
		execute: function(vm) {
			// TODO: \ operator.
			let rhs = vm.stack.pop()
			if (rhs === 0) throw new RuntimeError(RuntimeErrorCodes.DIVISION_BY_ZERO, 'Division by zero')
			let lhs = vm.stack.pop()
			vm.stack.push(lhs / rhs)
		}
	},

	MOD: {
		name: 'mod',
		numArgs: 0,
		execute: function(vm) {
			let rhs = vm.stack.pop()
			if (rhs === 0) throw new RuntimeError(RuntimeErrorCodes.DIVISION_BY_ZERO, 'Division by zero')
			let lhs = vm.stack.pop()
			vm.stack.push(lhs % rhs)
		}
	},

	BZ: {
		name: 'bz',
		addrLabel: true,
		execute: function(vm, arg) {
			// Branch on zero. Pop the top of the stack. If zero, jump to
			// the given address.
			let expr = vm.stack.pop()
			if (!expr) {
				vm.pc = arg
			}
		}
	},

	BNZ: {
		name: 'bnz',
		addrLabel: true,
		execute: function(vm, arg) {
			// Branch on non-zero. Pop the top of the stack. If non-zero, jump
			// to the given address.
			let expr = vm.stack.pop()
			if (expr) {
				vm.pc = arg
			}
		}
	},

	JMP: {
		name: 'jmp',
		addrLabel: true,
		execute: function(vm, arg) {
			// Jump to the given address.
			vm.pc = arg
		}
	},

	CALL: {
		name: 'call',
		addrLabel: true,
		execute: function(vm, arg) {
			// Call a function or subroutine. This creates a new stackframe
			// with no variables defined.
			vm.frame = new StackFrame(vm.pc)
			vm.callstack.push(vm.frame)
			vm.pc = arg
		}
	},

	GOSUB: {
		name: 'gosub',
		addrLabel: true,
		execute: function(vm, arg) {
			// like call, but stack frame shares all variables from the old
			// stack frame.
			let oldvariables = vm.frame.variables
			vm.frame = new StackFrame(vm.pc)
			vm.frame.variables = oldvariables
			vm.callstack.push(vm.frame)
			vm.pc = arg
		}
	},

	RET: {
		name: 'ret',
		numArgs: 0,
		execute: function(vm) {
			// Return from a gosub, function, or subroutine call.
			const returnAddr = vm.callstack.pop()
			if (returnAddr === undefined) throw new RuntimeError(RuntimeErrorCodes.STACK_UNDERFLOW, 'Stack underflow')
			vm.pc = returnAddr.pc
			vm.frame = vm.callstack[vm.callstack.length - 1]
		}
	},

	PUSHCONST: {
		name: 'pushconst',
		execute: function(vm, arg) {
			// Push a constant value onto the stack. The argument is a
			// javascript string or number.

			vm.stack.push(arg)
		}
	},

	ARRAY_DEREF: {
		name: 'array_deref',
		numArgs: 1,
		execute: function(vm, arg) {
			// Dereference an array. The top of the stack is the variable
			// reference, followed by an integer for each dimension.

			// Argument is whether we want the reference or value.

			// get the variable
			let variable = vm.stack.pop()

			let indexes: number[] = []

			// for each dimension,
			for (let i = 0; i < variable.dimensions.length; i++) {
				// pop it off the stack in reverse order.
				const index = vm.stack.pop()
				if (index === undefined) throw new RuntimeError(RuntimeErrorCodes.STACK_UNDERFLOW, 'Stack underflow')
				indexes.unshift(index)
			}

			// TODO: bounds checking.
			if (arg) {
				vm.stack.push(variable.access(indexes))
			} else {
				vm.stack.push(variable.access(indexes).value)
			}
		}
	},

	MEMBER_DEREF: {
		name: 'member_deref',
		execute: function(vm, arg) {
			// Dereference a user defined type member.
			// Argument is the javascript string containing the name of the
			// member. The top of the stack is a reference to the user
			// variable.

			let userVariable = vm.stack.pop()
			let deref = userVariable[arg]

			vm.stack.push(deref)
		}
	},

	MEMBER_VALUE: {
		name: 'member_value',
		execute: function(vm, arg) {
			// Dereference a user defined type member.
			// Argument is the javascript string containing the name of the
			// member. The top of the stack is a reference to the user
			// variable.

			let userVariable = vm.stack.pop()
			let deref = userVariable[arg]

			vm.stack.push(deref.value)
		}
	},

	ASSIGN: {
		name: 'assign',
		numArgs: 0,
		execute: function(vm) {
			// Copy the value into the variable reference.
			// Stack: left hand side: variable reference
			// right hand side: value to assign.

			let lhs = vm.stack.pop()
			let rhs = vm.stack.pop()

			lhs.value = lhs.type.copy(rhs)
		}
	},

	SYSCALL: {
		name: 'syscall',
		execute: function(vm, arg) {
			let variable
			let type
			let x
			let spaces
			let i
			// Execute a system function or subroutine. The argument is a
			// javascript string containing the name of the routine.
			if (vm.debug) {
				vm.trace.printf('Execute syscall %s\n', arg)
			}
			if (arg === 'print') {
				let num = 1
				for (i = 0; i < num; i++) {
					let what = vm.stack.pop()
					if (vm.debug) {
						vm.trace.printf('printing %s\n', what)
					}
					vm.cons.print('' + what)
				}
			} else if (arg === 'alloc_array') {
				type = vm.stack.pop()
				let numDimensions = vm.stack.pop()
				let dimensions: Dimension[] = []
				for (i = 0; i < numDimensions; i++) {
					let upper = vm.stack.pop()
					let lower = vm.stack.pop()
					dimensions.unshift(new Dimension(lower, upper))
				}

				variable = new ArrayVariable(type, dimensions)
				vm.stack.push(variable)
			} else if (arg === 'print_comma') {
				x = vm.cons.x
				spaces = ''
				while (++x % 14) {
					spaces += ' '
				}
				vm.cons.print(spaces)
			} else if (arg === 'print_tab') {
				let col = vm.stack.pop() - 1
				x = vm.cons.x
				spaces = ''
				while (++x < col) {
					spaces += ' '
				}
				vm.cons.print(spaces)
			} else if (arg === 'alloc_scalar') {
				type = vm.stack.pop()
				variable = new ScalarVariable(type, type.createInstance())
				vm.stack.push(variable)
			} else if (SystemFunctions[arg]) {
				SystemFunctions[arg].action(vm)
			} else if (SystemSubroutines[arg]) {
				SystemSubroutines[arg].action(vm)
			} else {
				throw new RuntimeError(RuntimeErrorCodes.UKNOWN_SYSCALL, 'Unknown syscall: ' + arg)
			}
		}
	}
}
